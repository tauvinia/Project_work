---
title: "Project"
format: html
editor: visual
---

# Packages

```{r}
## Default repository
local({r <- getOption("repos")
r["CRAN"] <- "http://cran.r-project.org" 
options(repos=r)
})

## Define function check_pkg to tests if package is already installed and hence only needs loading
check_pkg <- function(x)
{
  if (!require(x,character.only = TRUE))
  {
    install.packages(x,dep=TRUE)
    if(!require(x,character.only = TRUE)) stop("Package not found")
  }
}

## Call check_pkg()
check_pkg("pacman")
check_pkg("dplyr")
check_pkg("ggplot2")
check_pkg("readr")
check_pkg("tidyr")
check_pkg("sf")
check_pkg("terra")
check_pkg("tmap")
check_pkg("zoo")
check_pkg("units")
check_pkg("plotly")
check_pkg("patchwork")
check_pkg("gitcreds")
check_pkg("lubridate")
check_pkg("readr")
check_pkg("forcats")
check_pkg("osmdata")
check_pkg("OpenStreetMap")
check_pkg("ggmap")
check_pkg("osmextract")
check_pkg("sfnetworks")
```

# Trajectory data

## Read data

```{r}
## Read data 
# Small dataset
data <- read_delim("data/combined_data.csv", ",") |>
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326, remove = FALSE) 

# Big dataset
data_1 <- read_delim("data/combined_data_1.csv", ",") |>
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326, remove = FALSE)
```

## Separate timestamp into date and time

```{r}
# Convert the timestamp to POSIXct
data$timestamp <- ymd_hms(data$timestamp)

# Extract date component
data$date <- as.Date(data$timestamp)

# Extract time component
data$time <- format(data$timestamp, format = "%H:%M:%S")

# View the modified dataset
head(data)
```

## Select data within Karlsruhe

`{# {r} # # Extract boundary of Karlsruhe # boundary <- getbb(place_name = "Karlsruhe") %>% #   opq() %>% #   add_osm_feature(key = "boundary", #                   value = "administrative") %>% #   osmdata_sf() %>% #   .$osm_multipolygons %>% #   filter(name == "Karlsruhe") #  # # Select data that is within this boundary # data <- st_intersection(data, boundary) #  # # Plot # ggplot() + #   geom_sf(data = boundary) + #   geom_sf(data = data, color = "green") #  # # Save # st_write(boundary, "data/boundary.gpkg") # st_write(data, "data/small_data.gpkg")`

Delete after we are done

```{r}
boundary <- st_read("data/boundary.gpkg")
data <- st_read("data/small_data.gpkg")

ggplot() +
  geom_sf(data = boundary) +
  geom_sf(data = data, color = "green")
```

## Start and end point of the route

Start point: KriegsstraÃŸe 183, 76135 Karlsruhe, Deutschland

End point: Klosterweg 28, 76131 Karlsruhe, Deutschland

```{r}
# Store start point
start_point <- st_point(c(8.36964749052686, 49.00535930123405)) %>% 
  st_sfc(crs = 4326)

# Store end point
end_point <- st_point(c(8.4230360394263, 49.020260402061204)) %>% 
  st_sfc(crs = 4326)
```

# Extract route

```{r}
## Start point
# Buffer
start_buffer <- st_buffer(start_point, dist = 10)

# Point in buffer
points_start_buffer <- st_intersection(bike_data, start_buffer)

# ##
# # Only one point per day
# points_start_buffer <- points_start_buffer %>%
#   mutate(distance = st_distance(., start_point))
# 
# # Find the closest point per day
# route_start_points <- points_start_buffer %>%
#   group_by(date) %>%
#   slice(which.min(distance)) %>%
#   ungroup()
###

# Calculate the distance of each point from the start point
points_start_buffer <- points_start_buffer %>%
  mutate(distance = st_distance(., start_point))

# Find the closest point per drive_id
route_start_points <- points_start_buffer %>%
  group_by(drive_id) %>%
  slice(which.min(distance)) %>%
  ungroup()

# Plot
ggplot() +
  geom_sf(data = start_buffer, color = "black", fill = "lightblue") +
  geom_sf(data = start_point, color = "darkblue") +
  geom_sf(data = points_start_buffer, color = "darkgrey") +
  geom_sf(data = route_start_points, color = "red")
```

```{r}
## End point
# Buffer
end_buffer <- st_buffer(end_point, dist = 100)

# Point in buffer
points_end_buffer <- st_intersection(bike_data, end_buffer)

##"
# Only one point per day (??)
points_end_buffer <- points_end_buffer %>%
  mutate(distance = st_distance(., end_point))

# # Find the closest point per day
# route_end_points <- points_end_buffer %>%
#   group_by(date) %>%
#   slice(which.min(distance)) %>%
#   ungroup()
# ###

# Find the closest point per day
route_end_points <- points_end_buffer %>%
  group_by(drive_id) %>%
  slice(which.min(distance)) %>%
  ungroup()
###

# Plot
ggplot() +
  geom_sf(data = end_buffer, color = "black", fill = "lightblue") +
  geom_sf(data = end_point, color = "darkblue") +
  geom_sf(data = points_end_buffer, color = "darkgrey") +
  geom_sf(data = route_end_points, color = "red")
```

Group by time

```{r}


```

```{r}
# Casting points to lines
data_line <- data |> 
  # dissolve to a MULTIPOINT
  summarise(do_union = FALSE) |> 
  st_cast("LINESTRING")


data_points <- st_as_sf(data.frame(geometry = c(start_point, end_point)))

# Summarize to create a LINESTRING from start_point to end_point
data_line <- data_points %>%
  summarise(geometry = st_union(geometry)) %>%
  st_cast("LINESTRING")
```

Separating the routes

```{r}
# Calculate time differences between consecutive points in seconds
bike_data <- data %>%
  arrange(timestamp) %>%  # Ensure data is sorted by time
  mutate(time_diff = c(NA, diff(timestamp)))

# Identify where the time difference exceeds 300 seconds (5 minutes)
bike_data <- bike_data %>%
  mutate(new_drive = ifelse(is.na(time_diff) | time_diff > 300, 1, 0))

# Assign drive IDs
bike_data <- bike_data %>%
  mutate(drive_id = cumsum(new_drive))

# View the resulting data
print(bike_data)
```

```{r}
```

# Environmental Features OSM

```{r}
# Explore features
available_features()

available_tags(feature = "highway")
```

## Create Street Network

```{r fig.width=50, fig.height=40}
# Extract highways
highway <- getbb(place_name = "Karlsruhe") %>%
  opq() %>%
  add_osm_feature(key = "highway") %>%
  osmdata_sf() %>%
  .$osm_lines 

# Convert object to sfnetwork object
street_network <- as_sfnetwork(highway, directed = FALSE) %>% # set as undirected
  st_intersection(boundary)
  
# Overview
street_network

# Plot
ggplot() +
  geom_sf(data = boundary, color = "black", fill = "white") +
  geom_sf(data = street_network %>% activate(edges) %>% st_as_sf(), aes(color = highway), size = 2) + 
  geom_sf(data = street_network %>% activate(nodes) %>% st_as_sf()) +
  theme_minimal()
```

Find nearest vertices of start and end point of the route

```{r}
# Coordinates of all nodes in the network
vertices_sf <- street_net %>%
  activate(nodes) %>%
  st_as_sf()

# Find the id of the vertex closest to start point
start_vertex <- st_nearest_feature(start_point, vertices_sf)

# Find the id of the vertex closest to end point
end_vertex <- st_nearest_feature(end_point, vertices_sf)

# Print
cat("Start Vertex:", start_vertex, "\n")
cat("End Vertex:", end_vertex)
```

## Trees

shift+ctrl+c to add and remove \#

```{r}
# # Extract trees
# trees <- getbb(place_name = "Karlsruhe") %>%
#   opq() %>%
#   add_osm_feature(key = "natural",
#                   value = "tree") %>%
#   osmdata_sf() %>%
#   .$osm_points %>%
#   st_intersection(boundary)
# 
# # Plot
# ggplot() +
#   geom_sf(data = boundary, color = "black", fill = "lightblue") +
#   geom_sf(data = trees, color = "darkgreen") +
#   theme_minimal()
# 
# st_write(trees, "data/trees.gpkg")
```

Delete when we are done

```{r}
trees <- st_read("data/trees.gpkg")

# Plot
ggplot() +
  geom_sf(data = boundary, color = "black", fill = "lightblue") +
  geom_sf(data = trees, color = "darkgreen") +
  theme_minimal()
```

## Parks

```{r}
# Extract green spaces
parks <- getbb(place_name = "Karlsruhe") %>%
  opq() %>%
  add_osm_feature(key = "leisure",
                  value = "park") %>%
  osmdata_sf() %>%
  .$osm_polygons %>%
  st_intersection(boundary)

# Plot
ggplot() +
  geom_sf(data = boundary, color = "black", fill = "lightblue") +
  geom_sf(data = parks, color = "darkgreen", fill = "darkgreen") +
  theme_minimal()
```

# Mapmatching GPS points to the road network

https://computationalmovementanalysis.github.io/FS24/Appendix/Appendix.html#mapmatching-gps-points-to-the-road-network

```{r}
# Store edges in variable
edges <- street_net %>% activate(edges) %>% st_as_sf()

# Union
edges <- st_union(edges)

# Get nearest point for each GPS location
nearest <- st_nearest_points(gps_locations, edges)

# Plot
ggplot() +
  geom_sf(data = nearest)
```

Example:

```{r}
library(sf)
library(tmap)

# Get a sample road dataset
HighWays <- read_sf(system.file("sqlite/test3.sqlite",package="sf"), "HighWays")[6, ] 

# since we want to find the closest location on the road over ALL roads
# we need to create a union of the roads first.
HighWays <- st_union(HighWays)

# Let's simulate 1000 GPS locations within 3km of the highway
gps_locations <- HighWays |> st_buffer(3000) |> st_sample(100)

# Now we can get the nearset point for each GPS location
nearest <- st_nearest_points(data, street_network)

# The output is a line for each point (see plot below)
# Now we need convert the output from LINE to POINT. 
# This doubles the number of features
near_p <- st_cast(nearest, "POINT")

# now we subset the points. Uneven numbers are the original
# points, even numbers are the new, mapmatched points.
near_from <- near_p[c(TRUE, FALSE)]
near_to <- near_p[c(FALSE,TRUE)]
```
